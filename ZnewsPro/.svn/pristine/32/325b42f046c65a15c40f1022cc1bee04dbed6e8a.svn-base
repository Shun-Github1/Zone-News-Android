package com.anssy.znewspro.utils.network.exception

import okhttp3.Request
import okhttp3.ResponseBody
import okio.Timeout
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Converter
import retrofit2.Response

/**
 * @Description TODO
 * @Author yulu
 * @CreateTime 2025年07月05日 14:38:11
 */

sealed class NetworkResponse<out T : Any, out U : Any> {
    data class Success<out T : Any>(val body:T) : NetworkResponse<T, Nothing>()
    data class NetError(val httpCode:Int?,val errorMsg:String?,val exception: Throwable?) : NetworkResponse<Nothing, Nothing>()
    data class UnknownError(val error: Throwable?) : NetworkResponse<Nothing, Nothing>()

    internal class NetworkResponseCall<S : Any, E : Any>(
        private val delegate: Call<S>,
        private val errorConverter: Converter<ResponseBody, E>
    ) : Call<NetworkResponse<S, E>> {
        override fun clone(): Call<NetworkResponse<S, E>> {
            return NetworkResponseCall(delegate.clone(), errorConverter)
        }

        override fun execute(): Response<NetworkResponse<S, E>> {
            throw UnsupportedOperationException("NetworkResponseCall doesn't support execute")
        }


        override fun enqueue(callback: Callback<NetworkResponse<S, E>>) {
            return delegate.enqueue(object : Callback<S> {
                override fun onResponse(call: Call<S>, response: Response<S>) {
                    val body = response.body()
                    val code = response.code()
                    val error = response.errorBody()

                    if (response.isSuccessful) {
                        if (body != null) {
                            callback.onResponse(
                                this@NetworkResponseCall,
                                Response.success(Success(body))
                            )
                        } else {

                            callback.onResponse(
                                this@NetworkResponseCall,
                                Response.success(UnknownError(null))
                            )
                        }
                    } else {
                        val errorBody = when {
                            error == null -> null
                            error.contentLength() == 0L -> null
                            else -> NetError(code, error.toString(), null)
                        }
                        if (errorBody != null) {
                            callback.onResponse(
                                this@NetworkResponseCall,
                                Response.success(errorBody)
                            )
                        } else {
                            callback.onResponse(
                                this@NetworkResponseCall,
                                Response.success(UnknownError(null))
                            )
                        }
                    }


                }

                override fun onFailure(call: Call<S>, t: Throwable) {
                    val networkResponse = when (t) {
                        is Exception -> NetError(null,null,t)
                        else -> UnknownError(t)
                    }
                    callback.onResponse(this@NetworkResponseCall, Response.success(networkResponse))
                }

            })
        }



        override fun isExecuted(): Boolean {
            return delegate.isExecuted
        }

        override fun cancel() {
            delegate.cancel()
        }

        override fun isCanceled(): Boolean {
            return delegate.isCanceled
        }

        override fun request(): Request {
            return delegate.request()
        }

        override fun timeout(): Timeout {
            return delegate.timeout()
        }
    }



}